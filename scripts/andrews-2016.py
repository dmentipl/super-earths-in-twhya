'''
iplot.py

Image plot

Make figures from fits files generated by MCFOST.

Data can be scattered light, dust thermal emission, and molecular line emission.
It can include polarization and velocity channels. The fits file may be
post-processed by CASA.

Files required are:
    - .fits file(s) containing the image data from MCFOST
    - .para file(s) from MCFOST with the same filename prefix as fits file
    - .json file with plotting options
    - (optional) top_left.txt, top_right.txt, bottom_left.txt, bottom_right.txt
      which contains annotation text for plots

Can be used in an ipython shell, or at the command line.

D. Mentiplay, 2017-2018
'''


# ---------------------------------------------------------------------------- #

import argparse
from argparse import RawTextHelpFormatter
from astropy.io import fits
from astropy import constants
from astropy import units
from cycler import cycler
import json
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse
from matplotlib.ticker import FuncFormatter
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
from numpy import pi
import os
from os.path import exists
from pprint import pprint
import sys
import re


# ---------------------------------------------------------------------------- #

c = constants.c.cgs.value
h = constants.h.cgs.value
kB = constants.k_B.cgs.value
arcsec = units.arcsec.cgs.scale
mas = units.mas.cgs.scale
Jy = units.Jansky.cgs.scale

# ---------------------------------------------------------------------------- #

# Options.
debug = False
max_brightness = 2
font_family = 'serif'  # 'sans-serif'
minor_ticks = False
plot_beam = True
add_text = True
Tbrightness = False
integer_ticks_labels = False
colorbar_per_axis = True
xlabel_valign = 0.02
ylabel_halign = 0.09
size_scaling = 2.45


# ---------------------------------------------------------------------------- #

# Matplotlib parameters.
mpl.rcParams['axes.prop_cycle'] = cycler('color', ['0.3', '0.3', '0.3', '0.3']) \
                                + cycler('linestyle', ['-', '--', ':', '-.'])
mpl.rcParams['font.size']   = 18.0
mpl.rcParams['font.family'] = font_family
mpl.rcParams['font.serif']  = 'Times New Roman'
if font_family == 'serif':
    mpl.rcParams['mathtext.fontset'] = 'custom'
    mpl.rcParams['mathtext.cal']     = 'cursive'
    mpl.rcParams['mathtext.rm']      = 'serif'
    mpl.rcParams['mathtext.tt']      = 'monospace'
    mpl.rcParams['mathtext.it']      = 'serif:italic'
    mpl.rcParams['mathtext.bf']      = 'serif:bold'
    mpl.rcParams['mathtext.sf']      = 'sans'


# ---------------------------------------------------------------------------- #

def get_data(prefix, opts):

    # Open fits file.
    filename = prefix+'.fits'
    if exists(filename):
        print('\nGetting data from ' + filename)
        hdulist = fits.open(filename)
        hdu = hdulist[0]
    else:
        print('Data file \'' + filename + '\' does not exist')
        sys.exit(1)

    # Get info from header.
    bunit = hdu.header['BUNIT']
    crpixx = hdu.header['CRPIX1']
    crpixy = hdu.header['CRPIX2']
    width_in_pixel = hdu.header['NAXIS1']
    arcsec_per_pixel = abs(hdu.header['CDELT1']) * 3600
    pixel_per_arcsec = 1/arcsec_per_pixel
    width_in_arcsec = arcsec_per_pixel * width_in_pixel
    middle_in_pixel = width_in_pixel/2
    if len(hdu.data.shape) == 4:
        freq_Hz = hdu.header['CRVAL3']
        wl_micron = c/freq_Hz * 1e4
    else:
        wl_micron = None

    # Make image tighter.
    if size_scaling is not None:
        fac = size_scaling
        leftpix = round(0.5*(1-1/fac)*width_in_pixel)
        rightpix = width_in_pixel-round(0.5*(1-1/fac)*width_in_pixel)
        width_in_arcsec = width_in_arcsec / fac
        width_in_pixel = width_in_pixel / fac
        middle_in_pixel = middle_in_pixel / fac

    # Get info from parameter file.
    para_file = prefix+'.para'
    if not exists(para_file):
        print('Parameter file \'' + para_file + '\' does not exist')
        sys.exit(1)
    else:
        file = open(para_file, 'r')
        for line in file.readlines():
            # Get image size in AU.
            if re.search('size \[AU\]', line, re.I):
                words=line.split()
                width_in_au=float(words[2])
        file.close()
    pixel_per_au = width_in_pixel / width_in_au

    # Get data.
    filename = prefix+'.fits'
    if exists(filename):
        hdulist = fits.open(filename)
        hdu = hdulist[0]
    else:
        print('Data file \'' + filename + '\' does not exist')
        sys.exit(1)

    # Check for type of image data.
    # Thermal emission.
    if len(hdu.data.shape) == 4:

        dtype = 'casa'
        img = hdu.data[0,0]

        if size_scaling is not None:
            img = img[leftpix:rightpix,leftpix:rightpix]

    # Scattered light.
    elif len(hdu.data.shape) == 5:

        dtype = 'pol'

        # Polarization.
        if opts['polarization'] is None:
            img = hdu.data[0,0,0]
        else:
            Q = hdu.data[1,0,0]
            U = hdu.data[2,0,0]
            V = hdu.data[3,0,0]
            print('Polarization: ' + opts['polarization'])
            if opts['polarization']=='Q':
                img = Q
            elif opts['polarization']=='Qphi':
                px = np.linspace(0,width_in_pixel-1,width_in_pixel)
                mx, my = np.meshgrid(px,px)
                phi = np.arctan2(mx-crpixx,my-crpixy)
                Qphi = -(Q * np.cos(2*phi) + U * np.sin(2*phi))
                img = Qphi
            elif opts['polarization']=='U':
                img = U
            elif opts['polarization']=='V':
                img = V
            else:
                print('Polarization is either Q, Qphi, U, or V')
                sys.exit(1)

    # CO maps.
    elif len(hdu.data.shape) == 6:

        # For now, can only plot sum of CO channel maps.
        dtype = 'mol'
        img = hdu.data[0,0,0]
        img = np.sum(img, axis=0)

    else:

        print('I don\'t recognize this data')
        sys.exit(1)

    dat = {'bunit': bunit,
           'crpixx': crpixx,
           'crpixy': crpixy,
           'dtype': dtype,
           'middle_in_pixel': middle_in_pixel,
           'pixel_per_au': pixel_per_au,
           'pixel_per_arcsec': pixel_per_arcsec,
           'wl_micron': wl_micron,
           'width_in_arcsec': width_in_arcsec,
           'width_in_au': width_in_au,
           'width_in_pixel': width_in_pixel}

    return img, dat


# ---------------------------------------------------------------------------- #

def process_image(img, opts, dat):

    # Unpack dat structure.
    crpixx = dat['crpixx']
    crpixy = dat['crpixy']
    pixel_per_arcsec = dat['pixel_per_arcsec']
    width_in_pixel = dat['width_in_pixel']

    # Add noise.
    if opts['noise'] is not None:
        gain = opts['noise'][0]
        fixed = opts['noise'][1]
        print('Noise: (gain,fixed) = (' + str(gain) + ',' + str(fixed) + ')')
        noise1 = 1 + gain  * np.random.randn(width_in_pixel,width_in_pixel)
        noise2 = np.abs(fixed * img * np.random.randn(width_in_pixel,width_in_pixel))
        img   = noise1 * img + noise2

    # Convolve with PSF.
    if opts['convolve']:
        if opts['beam'] is not None:
            FWHM_max_in_mas = opts['beam'][0]
            FWHM_min_in_mas = opts['beam'][1]
            PA              = opts['beam'][2]
            FWHM_max_in_pixels = FWHM_max_in_mas/1000 * pixel_per_arcsec
            FWHM_min_in_pixels = FWHM_min_in_mas/1000 * pixel_per_arcsec
            print('Convolve with beam with FWHM of (' + str(FWHM_max_in_mas) +
                  ',' + str(FWHM_min_in_mas) + ') mas at PA = ' + str(PA))
            sigma_x = FWHM_max_in_pixels / (2.*np.sqrt(2.*np.log(2)))
            sigma_y = FWHM_min_in_pixels / (2.*np.sqrt(2.*np.log(2)))
            psf = gauss_kernel2(int(max(sigma_x,sigma_y))*5,sigma_x,sigma_y,90.+PA)
            img = convol2df(img,psf)
            if debug:
                plt.imshow(psf)
                plt.show()
        else:
            print('Need to specify a beam to convolve with')
            sys.exit(1)

    # Scale by R^p.
    if opts['scaling'] is not None:
        print('Scaling by R^p where p = '+str(opts['scaling']))
        p = opts['scaling']
        px = np.linspace(0,width_in_pixel-1,width_in_pixel)
        mx, my = np.meshgrid(px,px)
        Rscaled_pix = abs(mx-crpixx+1)**p + abs(my-crpixy+1)**p
        Rscaled = Rscaled_pix/Rscaled_pix.max()
        img = Rscaled*img

    # Coronagraph.
    if opts['coronagraph']:
        print('Adding coronagraph of radius '+str(opts['coronagraph'])+' mas')
        px = np.linspace(0,width_in_pixel-1,width_in_pixel)
        mx, my = np.meshgrid(px,px)
        R_pix = np.sqrt((mx-crpixx+1)**2 + (my-crpixy+1)**2)
        R_arcsec = R_pix / pixel_per_arcsec
        img[R_arcsec<opts['coronagraph']/1000] = 0.
    else:
        img[img==img.max()] = 0.

    return img


# ---------------------------------------------------------------------------- #

def set_plot(img, opts, dat):

    # Unpack dat structure.
    bunit = dat['bunit']
    crpixx = dat['crpixx']
    crpixy = dat['crpixy']
    dtype = dat['dtype']
    middle_in_pixel = dat['middle_in_pixel']
    pixel_per_arcsec = dat['pixel_per_arcsec']
    pixel_per_au = dat['pixel_per_au']
    width_in_arcsec = dat['width_in_arcsec']
    width_in_au = dat['width_in_au']
    width_in_pixel = dat['width_in_pixel']

    # Axis tick labels.
    # Adjust manually depending on angular width of image.
    if opts['axes'] == 'arcsec':
        half_width = width_in_arcsec/2
        if half_width < 1:
            num_tick = 3
            max_tick = 0.5
        elif half_width < 2:
            num_tick = 5
            max_tick = 1.
        elif half_width < 3.:
            num_tick = 5
            max_tick = 2.
        elif half_width < 4.:
            num_tick = 7
            max_tick = 3.
        else:
            num_tick = 5
            max_tick = 4.
        ticks = np.linspace(-max_tick,max_tick,num_tick)
        tick_labels = np.flip(ticks,0)
        if integer_ticks_labels:
            tick_labels = ticks.astype(int)
        ticks = middle_in_pixel + pixel_per_arcsec * ticks
        xticks = ticks
        yticks = ticks
    elif opts['axes'] == 'au':
        half_width = width_in_au/2
        if half_width < 50:
            num_tick = 5
            max_tick = 40
        elif half_width < 100:
            num_tick = 7
            max_tick = 75
        elif half_width < 150:
            num_tick = 7
            max_tick = 120
        elif half_width < 200:
            num_tick = 7
            max_tick = 150
        else:
            num_tick = 7
            max_tick = 200
        ticks = np.linspace(-max_tick,max_tick,num_tick)
        if integer_ticks_labels:
            tick_labels = ticks.astype(int)
        ticks = middle_in_pixel + pixel_per_au * ticks
        xticks = ticks
        yticks = np.flip(xticks,0)

    # Set units for colorbar label.
    unit_label = 'surface brightness '
    if bunit == 'Jy/beam':
        unit_label = unit_label + '[mJy/beam]'
        img = img*1000
    elif bunit == 'JY/PIXEL':
        unit_label = unit_label + '[Jy/pixel]'
    elif bunit == 'W.m-2.pixel-1':
        unit_label = unit_label + '[W.m-2/pixel]'

    # Change image contrast or set max brightness.
    scale = 1.0
    if opts['contrast'] is not None:
        scale = opts['contrast']
    if max_brightness is not None:
        print('Setting vmax to max_brightness = ' + str(max_brightness))
        vmax = max_brightness
    else:
        vmax = scale*img.max()

    # Normalize. Overrides scaling.
    if opts['normalize']:
        img = img/np.max(img)
        unit_label = 'normalized brightness'
        vmax = 1.

    # Azimuthally average image.
    if not opts['cut'] and opts['average']:
        print('Taking azimuthal average')
        radial_brightness = radial_profile(img, (crpixx,crpixy))
        for mx in range(width_in_pixel):
            for my in range(width_in_pixel):
                R_pix = np.sqrt((mx-crpixx+1)**2 + (my-crpixy+1)**2)
                img[mx,my] = radial_brightness[int(R_pix)]

    # Set color map.
    if dtype == 'mol':
        cmap = 'viridis'
    elif dtype == 'pol':
        cmap = 'gist_heat'
    elif dtype == 'casa':
        cmap = 'inferno'

    # Plot options.
    plot = {'cmap': cmap,
            'xticks': xticks,
            'yticks': yticks,
            'tick_labels': tick_labels,
            'unit_label': unit_label,
            'vmax': vmax}

    return img, plot


# ---------------------------------------------------------------------------- #

def plot_image(img, fig, ax, idx, opts, dat, plot):

    # Unpack dat structure.
    pixel_per_au = dat['pixel_per_au']
    pixel_per_arcsec = dat['pixel_per_arcsec']
    width_in_pixel = dat['width_in_pixel']

    # Unpack plot options.
    xticks = plot['xticks']
    yticks = plot['yticks']
    tick_labels = plot['tick_labels']
    unit_label = plot['unit_label']
    vmax = plot['vmax']
    cmap = plot['cmap']

    # Plot.
    im = ax.imshow(img,cmap=cmap,vmin=0.0,vmax=vmax)

    # Axis tick labels.
    if idx == 0:
        labelleft = 'on'
    else:
        labelleft = 'off'
    ax.set_xticks(xticks)
    ax.set_yticks(yticks)
    ax.set_xticklabels(tick_labels)
    ax.set_yticklabels(tick_labels)
    if not opts['nolabels']:
        ax.tick_params(axis='both',
                       which='both',
                       color='white',
                       bottom='on',
                       top='on',
                       left='on',
                       right='on',
                       labelbottom='on',
                       labelleft=labelleft,
                       direction='in')
    else:
        ax.tick_params(axis='both',
                       which='both',
                       bottom='off',
                       top='off',
                       left='off',
                       right='off',
                       labelbottom='off',
                       labelleft='off')

    # Scale bar.
    if opts['scalebar'] is not None:
        scalebar_in_au = int(opts['scalebar'])
        scalebar_width = scalebar_in_au * pixel_per_au
        posx = 0.05*width_in_pixel
        posy = 0.05*width_in_pixel
        offsetx = scalebar_width/2
        offsety = 1.1*posy
        ax.plot((posx,posx+scalebar_width),(posy,posy),color='white',linewidth=2.0)
        ax.text(posx+offsetx,posy+offsety,str(scalebar_in_au)+' au',
                 horizontalalignment='center',color='white')

    # Add misc text.
    if add_text:
        text_files = ['top_left.txt', 'top_right.txt', 'bottom_left.txt', 'bottom_right.txt']
        posx = np.array([0.05, 0.95, 0.05, 0.95])*width_in_pixel
        posy = np.array([0.10, 0.10, 0.90, 0.90])*width_in_pixel
        ha = ['left', 'right', 'left', 'right']
        for indx, text_file in enumerate(text_files):
            if exists(text_file):
                with open(text_file) as f:
                    text_to_add = f.readlines()
                text_to_add = [x.strip() for x in text_to_add]
                if idx + 1 > len(text_to_add):
                    print('Not enough lines in text_to_add.txt')
                    sys.exit(1)
                text = text_to_add[idx]
                ax.text(posx[indx], posy[indx], text, ha=ha[indx], color='white')

    # Beam size.
    if plot_beam and opts['beam'] is not None:
        if not opts['convolve']:
            print('Plotting beam specified but NOT convolving')
            print('appropriate for plotting pre-convolved CASA ALMA data')
        else:
            print('Plotting beam ellipse')
        FWHM_max_in_mas = opts['beam'][0]
        FWHM_min_in_mas = opts['beam'][1]
        PA              = opts['beam'][2]
        FWHM_max_in_pixels = FWHM_max_in_mas/1000 * pixel_per_arcsec
        FWHM_min_in_pixels = FWHM_min_in_mas/1000 * pixel_per_arcsec
        posx = 0.05*width_in_pixel
        posy = 0.95*width_in_pixel
        ellipse1=Ellipse((posx,posy),width=FWHM_max_in_pixels,
                                     height=FWHM_min_in_pixels,
                                     angle=90.-PA,
                                     color='white',
                                     linewidth=1.0,
                                     fill=False)
        ax.add_artist(ellipse1)

    # Mask.
    if opts['mask'] is not None:
        mask_width_in_pixels = 2 * pixel_per_au * opts['mask']
        posx = 0.5*width_in_pixel
        posy = 0.5*width_in_pixel
        ellipse2=Ellipse((posx,posy),width=mask_width_in_pixels,
                                     height=mask_width_in_pixels,
                                     angle=0.,
                                     color='grey',
                                     linewidth=1.5,
                                     fill=True)
        ax.add_artist(ellipse2)

    # Legend, i.e. colorbar.
    if opts['colorbar'] and colorbar_per_axis:
        divider = make_axes_locatable(ax)
        cax = divider.append_axes('right', size='5%', pad=0.05)
        fig.colorbar(im, cax=cax, orientation='vertical', label=unit_label)

    return im

# ---------------------------------------------------------------------------- #

def plot_profile(img, ax, opts, dat, plot):

    # Unpack dat.
    crpixx = dat['crpixx']
    crpixy = dat['crpixy']
    middle_in_pixel = dat['middle_in_pixel']
    wl_micron = dat['wl_micron']
    width_in_arcsec = dat['width_in_arcsec']
    width_in_au = dat['width_in_au']
    width_in_pixel = dat['width_in_pixel']

    # Azimuthally average radial cut.
    if opts['average']:
        print('Taking azimuthal average')
        brightness = radial_profile(img, (crpixx,crpixy))
        brightness = brightness[0:int(width_in_pixel/2)]
        if Tbrightness:
            print('Converting to brightness temperature')
            BMAJ = opts['beam'][0]
            BMIN = opts['beam'][1]
            wl_cm = wl_micron / 1e4
            brightness = Flux_to_Tbrightness(brightness,wl_cm,BMAJ,BMIN)
        if opts['axes'] == 'arcsec':
            radius = np.linspace(0,width_in_arcsec/2,len(brightness))
        elif opts['axes'] == 'au':
            radius = np.linspace(0,width_in_au/2,len(brightness))
    else:
        brightness = img[int(middle_in_pixel)]

    # Radius range.
    if opts['radius'] is not None:
        R_min_idx = min(np.where(radius > opts['radius'][0])[0])
        R_max_idx = max(np.where(radius < opts['radius'][1])[0])
        radius = radius[R_min_idx:R_max_idx]
        brightness = brightness[R_min_idx:R_max_idx]

    # Unpack plot options.
    unit_label = plot['unit_label']

    # Normalize.
    if opts['normalize']:
        brightness = brightness/np.max(brightness)
        unit_label = 'normalized brightness'

    # Brightness temperature.
    if Tbrightness:
        unit_label = 'brightness temperature [K]'

    # Plot.
    if opts['log'] is None:
        ax.plot(radius,brightness)
    elif opts['log'] == 'x':
        ax.semilogx(radius,brightness)
    elif opts['log'] == 'y':
        ax.semilogy(radius,brightness)
    elif opts['log'] == 'xy':
        ax.loglog(radius,brightness)

    # Axis tick labels.
    if not opts['nolabels']:
        if opts['log'] is not None:
            formatter = FuncFormatter(lambda y, _: '{:.16g}'.format(y))
            ax.xaxis.set_major_formatter(formatter)
            if minor_ticks:
                ax.xaxis.set_minor_formatter(formatter)
            else:
                ax.tick_params(axis='x', which='minor', labelbottom='off')
        if opts['axes'] == 'arcsec':
            ax.set_xlabel(r'$\Delta\alpha$ [arcsec]')
        elif opts['axes'] == 'au':
            ax.set_xlabel('radius [au]')
        ax.set_ylabel(unit_label)


# ---------------------------------------------------------------------------- #

def generate_plot(prefixes, opts):

    # Set up figure and axes.
    nfiles = len(prefixes)
    if opts['cut'] or nfiles == 1:
        fig, ax = plt.subplots()
        axes = [ax for number in range(nfiles)]
    else:
        w, h = plt.figaspect(nfiles)
        fig, axes = plt.subplots(1, nfiles, figsize=(h,w))
        fig.subplots_adjust(wspace=0.0)

    for idx, prefix in enumerate(prefixes):

        # Get image data and header info.
        img, dat = get_data(prefix, opts)

        # Process image.
        img = process_image(img, opts, dat)

        # Set plot options.
        img, plot = set_plot(img, opts, dat)

        # Plot image or radial profile.
        if not opts['cut']:

            # Plot image.
            im = plot_image(img, fig, axes[idx], idx, opts, dat, plot)

        else:

            # Plot radial profile.
            plot_profile(img, axes[idx], opts, dat, plot)

    # Axis labels.
    # For subplots may need to adjust manually:
    #   see xlabel_valign, ylabel_halign above.
    if not opts['nolabels']:
        if nfiles > 1:
            if opts['axes'] == 'arcsec':
                fig.text(0.5, xlabel_valign, r'$\mathrm{\Delta\alpha\ [arcsec]}$',
                         ha='center')
                fig.text(ylabel_halign, 0.5, r'$\mathrm{\Delta\delta\ [arcsec]}$',
                         va='center', rotation='vertical')
            elif opts['axes'] == 'au':
                fig.text(0.5, xlabel_valign, 'radius [au]', ha='center')
                fig.text(ylabel_halign, 0.5, 'radius [au]',
                         va='center', rotation='vertical')

        else:
            if opts['axes'] == 'arcsec':
                ax.set_xlabel(r'$\mathrm{\Delta\alpha\ [arcsec]}$')
                ax.set_ylabel(r'$\mathrm{\Delta\delta\ [arcsec]}$')
            elif opts['axes'] == 'au':
                ax.set_xlabel('radius [au]')
                ax.set_ylabel('radius [au]')

    if opts['colorbar'] and not colorbar_per_axis:
        fig.subplots_adjust(right=0.9)
        cbar_ax = fig.add_axes([0.91, 0.11, 0.01, 0.77])
        fig.colorbar(im, cax=cbar_ax, orientation='vertical', label=plot['unit_label'])

# ---------------------------------------------------------------------------- #

def get_command_line_opts():

    # Read command line args.
    description, epilog = options_help()
    parser = argparse.ArgumentParser(formatter_class=RawTextHelpFormatter,
                                     description=description,
                                     epilog=epilog)
    parser.add_argument('-o', '--options',
                        help='options file name without the .json',
                        required=False)
    parser.add_argument('-p', '--prefix',
                        nargs='+',
                        help='prefix(es) for data (.fits) and MCFOST parameter file (.para)',
                        required=True)
    parser.add_argument('-s', '--save',
                        help='save as [pdf|png|jpeg]',
                        required=False)
    args = parser.parse_args()

    # Check if data and para file are available.
    prefixes = args.prefix
    for prefix in prefixes:
        if not exists(prefix + '.fits'):
            print('Data file \'' + prefix + '.fits' + '\' does not exist')
            sys.exit(1)
        if not exists(prefix + '.para'):
            print('Parameter file \'' + prefix + '.para' + '\' does not exist')
            sys.exit(1)

    # Get options.
    if args.options is not None:
        filename = args.options + '.json'
    else:
        filename = args.options
    opts = get_options(filename)

    # Set save option.
    if args.save is not None:
        tmp, ext = os.path.splitext(args.save)
        if ext == '':
            save_format = tmp
        else:
            save_format = ext[1:]
        if save_format not in ('pdf', 'png', 'jpeg'):
            print('Save format should be pdf, png, or jpeg')
            sys.exit(1)
        else:
            save_format = args.save
    else:
        save_format = None

    # Print out options used.
    print('\nCurrent options:')
    pprint(opts)
    print('')

    # Return.
    return prefixes, save_format, opts


# ---------------------------------------------------------------------------- #

def check_options(opts):

    print('Checking options for consistency')
    print('And rewriting if necessary')

    for key, value in opts.items():
        if key in ('average', 'colorbar', 'cut', 'nolabels', 'normalize'):
            if opts[key] is None:
                opts[key] = False

    if opts['axes'] is None:
        opts['axes'] = 'au'
        print('Using default axes [au]')
    else:
        if opts['axes'] not in ('au', 'arcsec'):
            print('Axes is either au or arcsec')
            sys.exit(1)

    if opts['radius'] is not None:
        if opts['axes'] == 'arcsec':
            print('Cannnot use arcsec axes with radius range')
            sys.exit(1)

    return opts


# ---------------------------------------------------------------------------- #

def get_options(options_file):

    # Check if options_file is available.
    print('')
    if options_file is not None:
        if exists(options_file):
            # Use parameter values from json file.
            print('Using options file: \''+options_file+'\'')
            with open(options_file) as data_file:
                opts = json.load(data_file)
        else:
            print('Options file \'' + options_file + '\' does not exist')
            print('Check your files')
            sys.exit(1)
    else:
        # No options file available.
        opts = {'average':      False,
                'axes':         'au',
                'beam':         None,
                'colorbar':     False,
                'contrast':     None,
                'convolve':     False,
                'coronagraph':  None,
                'cut':          False,
                'log':          None,
                'mask':         None,
                'nolabels':     False,
                'noise':        None,
                'normalize':    False,
                'polarization': None,
                'radius':       None,
                'scalebar':     None,
                'scaling':      None}
        print('No options.json file specified')
        text = input('Would you like a default .json file? [y|n] ')
        if text == 'y':
            # Write default options file.
            print('Writing default options json file')
            set_options(opts, 'default')
            sys.exit(1)
        elif text == 'n':
            # Continue with default options.
            print('Using default options')
            opts = check_options(opts)
        else:
            print('Must answer with y or n')
            sys.exit(1)

    # Check consistency.
    opts = check_options(opts)

    return opts


# ---------------------------------------------------------------------------- #

def set_options(opts, filename):

    filename = filename + '.json'
    print('Writing current options to file: ' + filename)
    with open(filename, 'w') as fp:
        json.dump(opts, fp, sort_keys=True, indent=4)


# ---------------------------------------------------------------------------- #

def options_help():

    description = 'iplot = [i]mage [plot]'
    epilog = '''
options available in options file:

  average        azimuthally average                    T/F
  axes           axes units                             'au', 'arcsec'
  beam           specify beam ellipse (FWHM, PA)        [BMAJ,BMIN,PA] (mas & deg.)
  colorbar       add colorbar to plot                   T/F
  convolve       convolve with beam specified           T/F
  contrast       scale intensity: vmax = con*max(img)   con (dimensionless)
  coronagraph    add coronagraph                        radius (in mas)
  cut            make a radial cut                      T/F
  log            log plot                               'x', 'y', 'xy'
  mask           mask inner region                      radius (in au)
  nolabels       do not show axis labels                T/F
  noise          add noise                              [gain,fixed]
  normalize      normalize brightness                   T/F
  polarization   for scattered light images             'Q', 'Qphi', 'U', 'V'
  radius         minimum and maximum radius             [min,max] (in au)
  scalebar       add scalebar                           length (in au)
  scaling        scale intensity by R^p                 p
'''

    return description, epilog


# ---------------------------------------------------------------------------- #

def Flux_to_Tbrightness(flux, wl, BMAJ, BMIN):
    '''
    From C. Pinte

    Convert flux [mJy] to brightness temperature [K]
        flux [mJy]
        wl [cm]
        BMAJ, BMIN in [mas]
        T [K]
    '''

    # Frequency.
    nu = c/wl

    # Convert beam to radians.
    BMAJ = BMAJ * mas
    BMIN = BMIN * mas

    # Convert flux to cgs.
    flux = flux * (Jy/1000)
    flux = flux / (BMIN*BMAJ * np.pi/4/np.log(2))

    # Check for bad values.
    flux[(flux < 0)] = np.min(flux[(flux > 0)])

    # Calculate temperature using Planck.
    exp_m1 = 2*h*nu**3/(flux*c**2)
    exp_m1[(exp_m1 < 1e-10)] = 1e-10
    hnu_kT = np.log(exp_m1 + 1)
    T = h*nu / (hnu_kT*kB)

    return T


# ---------------------------------------------------------------------------- #

def Tbrightness_to_Flux(T, wl, BMAJ, BMIN):
    '''
    From C. Pinte

    Convert brightness temperature [K] to flux density [mJy]
        T [K]
        wl [cm]
        BMAJ, BMIN in [mas]
        flux [mJy]
    '''

    # Frequency.
    nu = c/wl

    # Calculate flux.
    flux = 2*h*nu**3/(c**2) / (np.exp(h*nu/(kB*T)) - 1)

    # Convert beam to radians.
    BMAJ = BMAJ * mas
    BMIN = BMIN * mas

    # Convert flux to mJy.
    flux = flux / (Jy/1000)
    flux = flux * (BMIN*BMAJ * np.pi/4/np.log(2))

    return flux


# ---------------------------------------------------------------------------- #

def gauss_kernel2(npix,sigma_x,sigma_y,PA):
    '''
    From C Pinte.

    gauss_kernel2(npix,sigma_x,sigma_y,PA)
    sigma_x et y en pix PA en degres
    PA defini depuis la direction verticale dans le sens horaire
    Cree un noyau gaussien dont l'intégrale vaut 1
    Marche pour npix pair et impair
    SEE ALSO:
    '''

    if (sigma_x < 1.0e-30):
        sigma_x = 1.0e-30
    if (sigma_y < 1.0e-30):
        sigma_y = 1.0e-30

    PA = PA * pi / 180.

    centre = npix/2. - 0.5

    px = np.linspace(0,npix-1,npix)
    mx, my = np.meshgrid(px,px)
    mx = mx - centre
    my = my - centre

    x = mx * np.cos(PA) - my * np.sin(PA)
    y = mx * np.sin(PA) + my * np.cos(PA)

    x = x / sigma_x
    y = y / sigma_y

    dist2 = x**2 + y**2

    tmp = np.exp(-0.5*dist2)

    return tmp/sum(sum(tmp))


# ---------------------------------------------------------------------------- #

def convol2df(im,psf):
    '''
    From C Pinte.
    '''

    psf2 = im * 0.

    dx=im.shape[0]
    dy=im.shape[1]

    dx2=psf.shape[0]
    dy2=psf.shape[0]

    startx = int((dx-dx2)/2)
    starty = int((dy-dy2)/2)

    psf2[startx:startx+dx2,starty:starty+dy2] = psf

    fim = np.fft.fft2(im)
    fpsf = np.fft.fft2(psf2)

    fim = fim * fpsf

    im = np.fft.ifft2(fim)
    im = np.roll(im,(int(dx/2),int(dy/2)),(0,1))
    im = abs(im) / (dx*dy)

    return im


# ---------------------------------------------------------------------------- #

def radial_profile(data, center):

    y, x = np.indices((data.shape))
    r = np.sqrt((x - center[0])**2 + (y - center[1])**2)
    r = r.astype(np.int)

    tbin = np.bincount(r.ravel(), data.ravel())
    nr = np.bincount(r.ravel())
    radialprofile = tbin / nr

    return radialprofile


# ---------------------------------------------------------------------------- #

def save_figure(prefixes, opts, save_format='pdf'):

    # Generate figure.
    plt.close()
    generate_plot(prefixes, opts)

    # Save figure.
    filename, ext = os.path.splitext(save_format)
    if ext == '':
        save_format = filename
        filename = 'iplot'
    else:
        save_format = ext[1:]
    if save_format in ('pdf', 'png', 'jpeg'):
        filename = filename + '.' + save_format
        print('\nSaving plot as ' + filename)
        plt.savefig(filename)
        if save_format == 'pdf':
            os.system('pdfcrop %s %s &> /dev/null &' % (filename, filename))
    else:
        print('Save format should be pdf, png, or jpeg')


# ---------------------------------------------------------------------------- #

if __name__ == '__main__':

    # Get options.
    prefix, save_format, opts = get_command_line_opts()

    # Plot to screen or save figure.
    if save_format is not None:
        save_figure(prefix, opts, save_format)
    else:
        generate_plot(prefix, opts)
        plt.show()
